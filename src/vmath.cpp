#include "vmath.h"
#include <unistd.h>

int VLibRndSeed = 0;

/* Calculate (a**x mod n) */
int64_t ModExp (int64_t A, int64_t X, int64_t N)
{
  int64_t TheMod = 1;

  while (X > 0) {
    if (X % 2) TheMod = IMulMod (TheMod, A, N);
    A = IMulMod (A, A, N);
    X /= 2;
  } 

  return (TheMod);
}

/* Calculate Greatest Common Divisor via Euclid's */
int64_t GCD (int64_t X, int64_t Y)
{
  int64_t TheGCD;
  
  TheGCD = Y;

  if (X < 0) X = -X;
  if (Y < 0) Y = -Y;
  if ((X == 1) || (Y == 1)) return 1;
  
  while (X > 0) {
    TheGCD = X;
    X = Y % X;
    Y = TheGCD;
  }

  return (TheGCD);
}

/* Legendre Symbol. */
int64_t Legendre (int64_t A, int64_t X)
{
  int64_t Exp;
  int64_t L;

  Exp = (X - 1) / 2;
  L = ModExp (A, Exp, X);
 
  switch (L) {
    case -1:    return (L_DIVISOR);
    case 0:     return (L_QUADRES);
    case 1:     return (L_NONRES);
  }

  return (L_UNKNOWN);
}

/* Integer Square Root via Newtons Method.  Acts like "Floor(Sqrt(X))" */
int64_t ISqrt (int64_t X)
{
  int64_t Guess = X / 2;
  int64_t Prv = 0;
  int64_t N = 0;

  if (X < 1) return (0);
  if (X < 2) return (1);
  if (X < 5) return (2);
  if (X < 10) return (3);

  while ((Guess != 0) && (Prv != Guess) && (N != 1)) {
    Prv = Guess;
    N = (Guess / 2) - (X / (2 * Guess)); 
    Guess = Guess - N;
  } 
 
  return (Guess);
}

/* This returns 0 if no factors are found */
int64_t FactorSmTD (int64_t X)
{
  if (!(X % 2)) return (2);     /* 50% of all numbers    */
  if (!(X % 3)) return (3);     /* An additional 16.5%   */
  if (!(X % 5)) return (5);     /* An additional 3.3%    */
  if (!(X % 7)) return (7);     /* An additional 0.5%... */
  if (!(X % 11)) return (11);
  if (!(X % 13)) return (13);
  if (!(X % 17)) return (17);
  if (!(X % 23)) return (23);
  if (!(X % 27)) return (27);
  if (!(X % 29)) return (29);
  return (0);
}

/* Returns a factor of X if composite, or 0 if X is prime. 
   Z/nZ is generated by F(x) = (x**2 + 1) */
int64_t FactorPollard (int64_t X)
{
  int64_t Base;
  int64_t i = 0;
  int64_t Trial;
  int64_t N;

  N = FactorSmTD (X);
  if (N > 1) return (N);
  if (RabinMiller(RM_TRIALS, X) == I_PRIME) return (0);

  Base = VMathRandom() % X;
  i = VMathRandom() % (X - 1);
  do {
    i++;
    Trial = ModExp (Base, i, X);
    Trial--;
    N = GCD (Trial, X);
    if (N == 1) {
      Trial += 2;
      N = GCD (Trial, X);
    }
  } while (N == 1);

  return (N);
}

/* Rabin Miller -- Probable primality test. */
int64_t RabinMiller(int64_t Trials, int64_t X)
{
  int64_t R = 0, Flg = 0;
  int64_t Y = 0;
  int64_t Q = 0;
  int64_t i = 0, j = 0, k = 0;

  if (!(X % 2) || !(X % 3) || !(X % 5) || !(X % 7) || !(X % 11)) 
	   return (I_COMPOSITE);

  Q = X - 1;
  while ((Q & 1) == 0) {
    k++;
    Q >>= 1;
  }

  for (i = 0; i < Trials; i++) {
    R = (VMathRandom () % (X - 1)) + 1;
    Y = ModExp (R, Q, X);
    if ((Y == 1) || (Y == (X - 1))) continue;
    Flg = 0;
    for (j = 1; j < k; j++) {
      Y = IMulMod (Y, Y, X);
      if (Y == (X - 1)) {
	Flg = 1;
	break;
      }  
      if (Y == 1) return (I_COMPOSITE);
    }
    if (Flg == 1) continue;
    return (I_COMPOSITE);
  }
  return (I_PRIME);
}

int64_t VMathRandom (void)
{
  if (VLibRndSeed == 0) {
#ifdef WIN32
	  srand (_getpid());
#else
    srandom (getpid());
#endif
    VLibRndSeed = 1;
  }
#ifdef WIN32
  return ((rand() << 32) | rand ());
#else
  return ((random() << 32) | random());
#endif

}

int64_t IMulMod (int64_t x, int64_t y, int64_t mod)
{
  int64_t x2;
  int64_t y2;
  int64_t n = 0;

  x2 = x % mod;
  y2 = y % mod;

  while (y2) {
    if (y2 & 1) n += x2;
    y2 >>= 1;
    x2 <<= 1;
    y2 %= mod;
    x2 %= mod;
    n %= mod;
  }
 
  return (n);
}

int64_t NextPrime (int64_t CurPrime)
{
  if ((CurPrime % 2) == 0) CurPrime ++;
  while (RabinMiller (RM_TRIALS, CurPrime) == I_COMPOSITE) CurPrime +=2;
  return (CurPrime);
}
